# Heroes — Алгоритмы боевой системы

Проект реализует ключевые алгоритмы для пошаговой стратегии с боевой системой.

## Реализованные алгоритмы

### 1. Генерация армии противника (`GeneratePresetImpl.generate`)

**Описание:** Формирует армию компьютера с максимальной эффективностью по соотношению атака/стоимость.

**Алгоритм:** Жадный алгоритм (Greedy)

**Принцип работы:**
1. Сортировка типов юнитов по эффективности:
   - Первичный критерий: `baseAttack / cost` (убывание)
   - Вторичный критерий: `health / cost` (убывание)
2. Последовательное добавление юнитов наиболее эффективного типа
3. Ограничения: до 11 юнитов каждого типа, общая стоимость ≤ `maxPoints`

**Алгоритмическая сложность: O(n × m)**

Обоснование:
- Сортировка типов юнитов: O(n log n), где n — количество типов (4 типа)
- Цикл по типам: O(n)
- Внутренний цикл добавления юнитов: O(m), где m = 11 (максимум юнитов на тип)
- Итого: O(n log n) + O(n × m) = O(n × m)

---

### 2. Симуляция боя (`SimulateBattleImpl.simulate`)

**Описание:** Проводит пошаговый бой между армией игрока и армией компьютера.

**Алгоритм:** Раундовая симуляция с сортировкой по силе атаки

**Принцип работы:**
1. Пока в обеих армиях есть живые юниты:
   - Собрать всех живых юнитов обеих армий
   - Отсортировать по убыванию `baseAttack`
   - Каждый живой юнит атакует через `unit.getProgram().attack()`
   - Логировать результат через `printBattleLog`
2. Погибшие юниты пропускают свой ход

**Алгоритмическая сложность: O(n² × log n)**

Обоснование:
- Количество раундов: O(n) — в худшем случае каждый раунд погибает 1 юнит
- На каждом раунде:
  - Сбор живых юнитов: O(n)
  - Сортировка: O(n log n)
  - Атаки: O(n) × O(1) = O(n) (предполагая attack() работает за O(1))
- Итого: O(n) × O(n log n) = O(n² log n)

---

### 3. Поиск целей для атаки (`SuitableForAttackUnitsFinderImpl.getSuitableUnits`)

**Описание:** Определяет юнитов противника, доступных для атаки (не закрытых союзниками).

**Алгоритм:** Линейный проход по рядам

**Принцип работы:**
- Для каждого из 3 рядов:
  - Если `isLeftArmyTarget == true` (атакуем левую армию): выбираем юнита с минимальным `y` (самый левый, не закрыт)
  - Если `isLeftArmyTarget == false` (атакуем правую армию): выбираем юнита с максимальным `y` (самый правый, не закрыт)
- Мёртвые юниты игнорируются

**Алгоритмическая сложность: O(n)**

Обоснование:
- Внешний цикл по рядам: O(3) = O(1) — фиксированное количество рядов
- Внутренний цикл по юнитам в ряду: O(n/3) в среднем
- Итого: O(3 × n/3) = O(n) — линейная сложность

---

### 4. Поиск кратчайшего пути (`UnitTargetPathFinderImpl.getTargetPath`)

**Описание:** Находит кратчайший маршрут между атакующим и атакуемым юнитом на игровом поле.

**Алгоритм:** Дейкстра (Dijkstra's Algorithm) с приоритетной очередью

**Принцип работы:**
1. Создание сетки препятствий из позиций живых юнитов (кроме атакующего и цели)
2. Алгоритм Дейкстры от позиции атакующего до позиции цели
3. 8 направлений движения с разными весами:
   - Прямые ходы (вверх/вниз/влево/вправо): вес **1.0**
   - Диагональные ходы: вес **√2 ≈ 1.414**
4. Приоритетная очередь для выбора ближайшей непосещённой вершины
5. Восстановление пути через массив родителей
6. Если путь не найден — возврат пустого списка

**Константы:**
- WIDTH = 27 (ширина поля)
- HEIGHT = 21 (высота поля)

**Алгоритмическая сложность: O(W × H × log(W × H))**

Обоснование:
- Каждая клетка добавляется в приоритетную очередь максимум один раз: O(W × H)
- Операции с приоритетной очередью (add/poll): O(log(W × H))
- Для каждой клетки проверяется 8 соседей: O(1)
- Инициализация сетки препятствий: O(n), где n — количество юнитов
- Восстановление пути: O(W + H) в худшем случае
- Итого: O(W × H × log(W × H)) = O(567 × log(567)) ≈ O(567 × 9.15) ≈ O(5200)

**Преимущество перед BFS:** Учитывает реальные расстояния — диагональные ходы длиннее прямых, поэтому путь получается геометрически оптимальным.

---

## Структура проекта

```
src/main/java/programs/
├── GeneratePresetImpl.java      # Генерация армии
├── SimulateBattleImpl.java      # Симуляция боя
├── SuitableForAttackUnitsFinderImpl.java  # Поиск целей
└── UnitTargetPathFinderImpl.java # Поиск пути

src/test/java/programs/
├── GeneratePresetImplTest.java
├── SimulateBattleImplTest.java
├── SuitableForAttackUnitsFinderImplTest.java
└── UnitTargetPathFinderImplTest.java
```

## Требования

- **Java 23** или выше
- **Gradle 8.x** (или использовать встроенный `gradlew`)

## Установка и запуск

### 1. Клонирование репозитория

```bash
git clone git@github.com:JudexMars/heroes_student_task.git
cd heroes_student_task
```

### 2. Сборка проекта

```bash
./gradlew build
```

### 3. Запуск тестов

```bash
./gradlew test
```

Отчёт о тестах будет доступен в `build/reports/tests/test/index.html`.

### 4. Интеграция с основной игрой

Скомпилированные классы находятся в `build/classes/java/main/`.
Также артфеакты собраны в heroes_student_task.jar

## Зависимости

| Библиотека | Версия | Назначение |
|------------|--------|------------|
| Java | 23+ | Среда выполнения |
| JUnit Jupiter | 5.10.0 | Юнит-тестирование |
| Mockito | 5.14.2 | Мокирование в тестах |
| heroes_task_lib | 1.0-SNAPSHOT | Библиотека игры (предоставлена) |

Все зависимости автоматически загружаются через Gradle из Maven Central.
Библиотека `heroes_task_lib-1.0-SNAPSHOT.jar` должна находиться в папке `libs/`.

